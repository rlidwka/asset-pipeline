// Generated by CoffeeScript 1.6.3
(function() {
  var DepsManager, async, fs, logcheck, util;

  util = require('./util');

  fs = require('fs');

  async = require('async');

  logcheck = function(fn) {
    return function(file, cb) {
      return fn.call(this, file, function(err, res) {
        util.log(err ? "file " + file + " cannot be checked" : res ? "file " + file + " has been changed" : "file " + file + " is the same");
        return cb(err, res);
      });
    };
  };

  DepsManager = (function() {
    function DepsManager(base) {
      this.base = base;
      this.resolving = {};
      this.deplist = {
        '/': {}
      };
      this.files = {};
      this.fs_stat_queue = {};
      this.min_check_time = 1000;
    }

    DepsManager.prototype.set_state = function(obj) {
      this.resolving = obj.resolving;
      this.deplist = obj.deplist;
      return this.files = obj.files;
    };

    DepsManager.prototype.get_state = function() {
      var obj;
      obj = {};
      obj.resolving = this.resolving;
      obj.deplist = this.deplist;
      obj.files = this.files;
      return obj;
    };

    DepsManager.prototype.clear_deps = function(file) {
      return this.deplist[file] = {};
    };

    DepsManager.prototype.depends_on = function(file, dep) {
      util.log("file " + file + " depends on " + dep + "]");
      return this.deplist[file][dep] = true;
    };

    DepsManager.prototype.resolves_to = function(file, path) {
      var _this = this;
      if (path == null) {
        util.log("file " + file + " is not resolved");
        delete this.resolving[file];
        return;
      }
      util.log("file " + file + " is resolved into " + path);
      this.resolving[file] = path;
      return fs.stat(path, function(err, res) {
        if (err) {
          return;
        }
        return _this.files[path] = {
          checked: Date.now(),
          mtime: Number(res.mtime)
        };
      });
    };

    DepsManager.prototype._checkFile = function(file, cb) {
      var path,
        _this = this;
      if (this.resolving[file] == null) {
        return cb(null, false);
      }
      path = this.resolving[file];
      if (this.files[path] == null) {
        return cb(null, true);
      }
      if (this.files[path].mtime == null) {
        return cb(null, true);
      }
      if (Math.abs(Date.now() - this.files[path].checked) < this.min_check_time) {
        return cb(null, false);
      }
      if (this.fs_stat_queue[path] != null) {
        this.fs_stat_queue[path].push(cb);
        return;
      }
      this.fs_stat_queue[path] = [cb];
      return fs.stat(path, function(err, res) {
        var changed, newtime, _cb, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (err && err.code !== 'ENOENT') {
          _ref = _this.fs_stat_queue[path];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _cb = _ref[_i];
            _cb(err);
          }
          delete _this.fs_stat_queue[path];
          return;
        }
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          _ref1 = _this.fs_stat_queue[path];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            _cb = _ref1[_j];
            _cb(null, true);
          }
          delete _this.files[path].mtime;
          delete _this.fs_stat_queue[path];
          return;
        }
        newtime = Number(res.mtime);
        changed = newtime !== _this.files[path].mtime;
        _this.files[path].checked = Date.now();
        if (changed) {
          delete _this.files[path].mtime;
          util.log("fstat: file " + path + " has been changed");
        } else {
          util.log("fstat: file " + path + " is the same");
        }
        _ref2 = _this.fs_stat_queue[path];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          _cb = _ref2[_k];
          _cb(null, !!changed);
        }
        return delete _this.fs_stat_queue[path];
      });
    };

    DepsManager.prototype._checkDeps = function(file, cb) {
      var dep, funcs,
        _this = this;
      funcs = [];
      if (this.deplist[file] != null) {
        for (dep in this.deplist[file]) {
          funcs.push(this.check.bind(this, dep));
        }
      }
      return async.parallel(funcs, function(err, res) {
        var i;
        if (err) {
          return cb(err);
        }
        return cb(null, !!((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = res.length; _i < _len; _i++) {
            i = res[_i];
            if (!!i) {
              _results.push(1);
            }
          }
          return _results;
        })()).length);
      });
    };

    DepsManager.prototype.mtime = function(file) {
      var _ref;
      return (_ref = this.files[file]) != null ? _ref.mtime : void 0;
    };

    DepsManager.prototype.check = function(file, cb) {
      var _this = this;
      return async.parallel([this._checkFile.bind(this, file), this._checkDeps.bind(this, file)], function(err, res) {
        if (err) {
          return cb(err);
        }
        return cb(null, res[0] || res[1]);
      });
    };

    return DepsManager;

  })();

  /*
  		return cb(null, false) unless @resolving[file]?
  		path = @resolving[file]
  		return cb(null, false) unless @files[path]?
  		fs.stat(path, (err, res) =>
  			return cb(err) if err
  			newtime = Number(res.mtime)
  			if newtime != @files[path].mtime
  				return cb(null, true)
  
  			funcs = []
  			if @deplist[path]?
  				for dep of @deplist[path]
  					funcs.push @check.bind(@, dep)
  			async.parallel(funcs, (err, res) =>
  				return cb(err) if err
  				# if one of array is true return true, false otherwise
  				return cb(null, !!(1 for i in res when !!i).length)
  			)
  		)
  */


  module.exports = DepsManager;

}).call(this);
