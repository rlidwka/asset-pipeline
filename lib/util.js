// Generated by CoffeeScript 1.6.3
(function() {
  var NoConcurrent, Path, async, exports, fs, make_directories, util, _NoConcurrentCache, _do_log,
    __slice = [].slice;

  Path = require('./path');

  fs = require('fs');

  util = require('util');

  async = require('async');

  _do_log = process.env.NODE_DEBUG && /asset\-pipeline/.test(process.env.NODE_DEBUG);

  exports = module.exports = {};

  make_directories = function(dest, cb) {
    var dir;
    dir = Path.dirname(dest);
    if (dir === '.' || dir === '..') {
      return cb();
    }
    return fs.mkdir(dir, function(err) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return make_directories(dir, function() {
          return fs.mkdir(dir, cb);
        });
      } else {
        return cb();
      }
    });
  };

  exports.write_file = function(dest, data, cb) {
    var safe_write;
    safe_write = function(cb) {
      var tmpname;
      tmpname = dest + '.tmp' + String(Math.random()).substr(2, 5);
      return fs.writeFile(tmpname, data, function(err) {
        if (err) {
          return cb(err);
        }
        return fs.rename(tmpname, dest, cb);
      });
    };
    return safe_write(function(err) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return make_directories(dest, function() {
          return safe_write(cb);
        });
      } else {
        return cb(err);
      }
    });
  };

  _NoConcurrentCache = {};

  exports.NoConcurrent = NoConcurrent = function(key, cb, func) {
    if (_NoConcurrentCache[key] != null) {
      _NoConcurrentCache[key].push(cb);
      return;
    }
    _NoConcurrentCache[key] = [cb];
    return func(function() {
      var old_queue, _i, _len, _results;
      old_queue = _NoConcurrentCache[key];
      delete _NoConcurrentCache[key];
      _results = [];
      for (_i = 0, _len = old_queue.length; _i < _len; _i++) {
        func = old_queue[_i];
        _results.push(func.apply(null, arguments));
      }
      return _results;
    });
  };

  exports.link_file = function(src, dst, maincb) {
    var safe_link;
    safe_link = function(cb) {
      var tmpname;
      tmpname = dst + '.tmp' + String(Math.random()).substr(2, 8);
      return fs.link(src, tmpname, function(err) {
        if (err) {
          return cb(err);
        }
        return fs.rename(tmpname, dst, function(err) {
          cb(err);
          return fs.unlink(tmpname, function() {});
        });
      });
    };
    return NoConcurrent("link " + dst, maincb, function(cb) {
      return safe_link(function(err) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return make_directories(dst, function() {
            return safe_link(cb);
          });
        } else {
          return cb(err);
        }
      });
    });
  };

  exports.do_log = function(arg) {
    if (arg != null) {
      _do_log = !!arg;
    }
    return _do_log;
  };

  exports.log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (_do_log) {
      return util.log.apply(util, args);
    }
  };

}).call(this);
