// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Callback, END_SEQ, FuncID, Monad, Path, START_SEQ, Wrap, async, crypto, escape_chars, fs, gen_code, inlines_call, monads, util;

  fs = require('fs');

  async = require('async');

  Path = require('./path');

  crypto = require('crypto');

  util = require('./util');

  Cache = require('async-cache');

  gen_code = function(length) {
    var chars, code, i, _i;
    code = '';
    chars = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM';
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
  };

  START_SEQ = gen_code(12);

  END_SEQ = gen_code(4);

  FuncID = 0;

  escape_chars = ['\\', '&', '\'', '"', '<', '>'];

  monads = {};

  Monad = function(fn) {
    this.fn = fn;
    this.id = FuncID++;
    if (FuncID > 1e15) {
      FuncID = 0;
    }
    monads[this.id] = this;
    return this;
  };

  Monad.prototype.toString = function() {
    return "" + START_SEQ + this.id + "," + (escape_chars.join(',')) + END_SEQ;
  };

  Monad.prototype.unWrap = function(cb) {
    var _this = this;
    return this.fn(function(err, res) {
      delete monads[_this.id];
      if (err) {
        return cb(err);
      }
      return cb(null, _this._doReplace(res));
    });
  };

  Monad.prototype._doReplace = function() {};

  Monad.prototype._setReplace = function(str) {
    this._doReplace = function(code) {
      var idx, orig, repl, _i, _len, _ref;
      _ref = str.split(',');
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        repl = _ref[idx];
        if (orig = escape_chars[idx]) {
          code = code.split(orig).join(repl);
        }
      }
      return code;
    };
    return this;
  };

  Callback = function() {
    this.callbacks = [];
    return this;
  };

  Callback.prototype.set = function(args) {
    var cb, _i, _len, _ref;
    this.args = args;
    _ref = this.callbacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cb = _ref[_i];
      cb.apply(null, this.args);
    }
    return this.callbacks = [];
  };

  Callback.prototype.func = function() {
    var _this = this;
    return function(cb) {
      if (_this.args != null) {
        return cb.apply(null, _this.args);
      } else {
        return _this.callbacks.push(cb);
      }
    };
  };

  Wrap = function(fn) {
    return function() {
      return new Monad(fn.apply(this, arguments));
    };
  };

  inlines_call = function(orig, result, pos, cb) {
    var id, newpos, replace;
    newpos = orig.indexOf(START_SEQ, pos);
    if (newpos === -1) {
      return cb(null, result + orig.substr(pos));
    }
    result += orig.substr(pos, newpos - pos);
    pos = newpos + START_SEQ.length;
    newpos = orig.indexOf(',', pos);
    id = orig.substr(pos, newpos - pos);
    pos = newpos + 1;
    newpos = orig.indexOf(END_SEQ, newpos);
    replace = orig.substr(pos, newpos - pos);
    return monads[id]._setReplace(replace).unWrap(function(err, res) {
      if (err) {
        return cb(err);
      }
      return process.nextTick(function() {
        return inlines_call(orig, result + res, newpos + END_SEQ.length, cb);
      });
    });
  };

  module.exports.call = function(code, cb) {
    return inlines_call(code, '', 0, cb);
  };

  module.exports.prepare = function(gopts) {
    var Inlines, compile_file, filename, get_digest, get_file, pipeline;
    pipeline = gopts.pipeline;
    filename = pipeline.path_to_req(gopts.filename);
    Inlines = {};
    get_file = function(file, cb) {
      file = Path.resolve(Path.dirname(filename), file);
      return pipeline.compile_file(file, function(err) {
        if (err) {
          return cb(err);
        }
        return fs.readFile(pipeline.req_to_cache(file), function(err) {
          if (!err) {
            pipeline.depmgr.depends_on(filename, file);
          }
          return cb.apply(null, arguments);
        });
      });
    };
    compile_file = function(file, cb) {
      file = Path.resolve(Path.dirname(filename), file);
      return pipeline.compile_file(file, function(err, rec) {
        if (err) {
          return cb(err);
        }
        pipeline.depmgr.depends_on(filename, file);
        return cb(err, pipeline.req_to_cache(file), rec);
      });
    };
    get_digest = function(file, cb) {
      if (pipeline._digest_cache == null) {
        pipeline._digest_cache = new Cache({
          max: 10000,
          maxAge: 2 * 60 * 60 * 1000,
          load: function(file, cb) {
            return fs.readFile(pipeline.req_to_cache(file), function(err, data) {
              var md5, res;
              if (err) {
                return cb(err);
              }
              md5 = crypto.createHash('md5');
              res = md5.update(data).digest('base64');
              res = res.replace(/[^A-Za-z0-9]/g, '').substr(0, 8);
              pipeline._digest_cache[file] = res;
              return cb(null, res);
            });
          }
        });
      }
      return compile_file(file, function(err, _, wasrecompiled) {
        if (err) {
          return cb(err);
        }
        if (wasrecompiled) {
          pipeline._digest_cache.del(file);
        }
        return pipeline._digest_cache.get(file, cb);
      });
    };
    Inlines.asset_include = Wrap(function(file, options) {
      var callback;
      if (options == null) {
        options = {};
      }
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_file(file, function(err) {
        var results;
        results = arguments;
        if (!err) {
          results[1] = results[1].toString('utf8');
          if (options.jsescape) {
            results[1] = results[1].replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/'/g, '\\\'').replace(/"/g, '\\\"');
          }
        }
        return callback.set(results);
      });
      return callback.func();
    });
    Inlines.asset_include_dir = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_include_path = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_dir = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_path = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_depend_on = Wrap(function(file) {
      var callback;
      callback = new Callback();
      pipeline.compile_file(file, function(err) {
        if (!err) {
          pipeline.depmgr.depends_on(filename, file);
        }
        return callback.set(arguments);
      });
      return callback.func();
    });
    Inlines.asset_digest = Wrap(function(file, options) {
      var callback;
      if (options == null) {
        options = {};
      }
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_digest(file, function(err, digest) {
        if (err) {
          return callback.set(arguments);
        }
        return callback.set([null, digest]);
      });
      return callback.func();
    });
    Inlines.asset_size = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_mtime = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_ctime = Wrap(function(file, options) {
      if (options == null) {
        options = {};
      }
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_uri = Wrap(function(file, options) {
      var callback;
      if (options == null) {
        options = {};
      }
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_digest(file, function(err, digest) {
        var base, ext, result, _ref;
        if (err) {
          return callback.set(arguments);
        }
        base = ((_ref = Path.basename(file).match(/^[0-9A-Za-z]{1,5}/)) != null ? _ref : [''])[0];
        if (base.length >= 5) {
          base = base.substr(0, 3);
        }
        ext = Path.extname(file);
        result = Path.join(Path.dirname(file), "" + base + "-" + digest + ext);
        return pipeline.register(file, result, function(err, final_uri) {
          if (err) {
            return callback.set([err]);
          }
          return callback.set([null, final_uri]);
        });
      });
      return callback.func();
    });
    Inlines.asset_echo = Wrap(function(msg) {
      return function(cb) {
        return cb(null, msg);
      };
    });
    return Inlines;
  };

  /*
  Debug = (name, fn) ->
  	(args...) ->
  		console.log("function #{name} called, args=[#{args.join(',')}]")
  		fn.call(@, args...)
  		console.log("function #{name} finished")
  
  somefunction = Debug 'somefunction', (x) ->
  	otherfunction(x+1)
  
  otherfunction = Debug 'otherfunction', (x) ->
  	x+2
  
  somefunction(1)
  */


}).call(this);
