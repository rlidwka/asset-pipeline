// Generated by CoffeeScript 1.6.3
(function() {
  var DepMgr, Inlines, MakePath, Path, Pipeline, Send, URL, async, crypto, fs, util;

  Path = require('./path');

  Send = require('send');

  URL = require('url');

  fs = require('fs');

  async = require('async');

  crypto = require('crypto');

  DepMgr = require('./depmgr');

  MakePath = require('./makepath');

  util = require('./util');

  Inlines = require('./inlines');

  Pipeline = (function() {
    function Pipeline(options) {
      var file, server, _base, _base1, _base2, _base3, _i, _len, _ref, _ref1, _ref2,
        _this = this;
      this.options = options;
      this.files = {};
      this.id = Math.random();
      if ((_base = this.options).assets == null) {
        _base.assets = './assets';
      }
      this.options.assets = Path.normalize(this.options.assets);
      if ((_base1 = this.options).cache == null) {
        _base1.cache = './cache';
      }
      this.options.cache = Path.normalize(this.options.cache);
      if ((_base2 = this.options).mount_point == null) {
        _base2.mount_point = '';
      }
      this.tempDir = Path.join(this.options.cache, 'tmp');
      this.staticDir = Path.join(this.options.cache, 'static');
      try {
        fs.mkdirSync(this.tempDir);
      } catch (_error) {}
      try {
        fs.mkdirSync(this.staticDir);
      } catch (_error) {}
      if (this.options.debug != null) {
        util.do_log(this.options.debug);
      }
      if ((_base3 = this.options).extensions == null) {
        _base3.extensions = ['.js', '.css'];
      }
      this.options.extensions = this.options.extensions.map(function(x) {
        if (x[0] === '.') {
          return x;
        } else {
          return '.' + x;
        }
      });
      this.depmgr = new DepMgr(this.options.assets);
      this.depmgr.min_check_time = (_ref = this.options.min_check_time) != null ? _ref : 1000;
      server = function(set_maxage) {
        if (set_maxage == null) {
          set_maxage = false;
        }
        return function(req, res, _next) {
          var next, sender;
          req.pause();
          next = function(err) {
            req.resume();
            return _next(err);
          };
          sender = Send(req, URL.parse(req.url).pathname);
          sender.root(_this.staticDir);
          if (set_maxage) {
            sender.maxage(365 * 24 * 60 * 60 * 1000);
          }
          sender.on('directory', function() {
            return next(new Error('directory found'));
          });
          sender.on('error', function(err) {
            return next(err);
          });
          return sender.pipe(res);
        };
      };
      this.servers = {
        normal: server(false),
        caching: server(true)
      };
      _ref2 = (_ref1 = this.options.files) != null ? _ref1 : [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        file = _ref2[_i];
        this.files[Path.join('/', file)] = {
          serve: true
        };
      }
      this.inlines = Inlines.prepare({
        filename: '/',
        pipeline: this
      });
      this.load_cache_state();
    }

    Pipeline.prototype.can_serve_file = function(file) {
      var ext, _i, _len, _ref, _ref1;
      if ((_ref = this.files[file]) != null ? _ref.serve : void 0) {
        return true;
      }
      _ref1 = this.options.extensions;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ext = _ref1[_i];
        if (Path.extname(file) === ext) {
          return true;
        }
      }
      return false;
    };

    Pipeline.prototype.load_cache_state = function() {
      var hash, name,
        _this = this;
      this.options.__json_version = 1;
      hash = crypto.createHash('md5');
      hash.update(JSON.stringify(this.options));
      name = hash.digest('base64').replace(/[^A-Za-z0-9]/g, '').substr(0, 12);
      this.state_filename = Path.join(this.tempDir, name + '.json');
      return fs.readFile(this.state_filename, function(err, res) {
        var object;
        if (err) {
          return;
        }
        try {
          object = JSON.parse(res);
          _this.files = object.files;
          _this.depmgr.set_state(object.depmgr);
          return util.log('state loaded successfully from ' + _this.state_filename);
        } catch (_error) {}
      });
    };

    Pipeline.prototype.save_cache_state = function(cb) {
      var _this = this;
      if (Number(new Date()) < this._state_last_written + 20000) {
        return;
      }
      this._state_last_written = Number(new Date());
      return setTimeout(function() {
        _this._state_last_written = Number(new Date());
        util.log('saving state to ' + _this.state_filename);
        return fs.writeFile(_this.state_filename, JSON.stringify({
          files: _this.files,
          depmgr: _this.depmgr.get_state()
        }), cb);
      }, 2000);
    };

    Pipeline.prototype.middleware = function() {
      var _this = this;
      return function(req, res, realNext) {
        var file, next, path, server, url, _ref;
        next = function() {
          var oldrender;
          oldrender = res.render;
          if (oldrender != null) {
            res.render = function(view, options, fn) {
              if (options == null) {
                options = {};
              }
              if ('function' === typeof options) {
                fn = options;
                options = {};
              }
              res.locals(_this.inlines);
              if ('function' !== typeof fn) {
                fn = function(err, code) {
                  if (err) {
                    return req.next(err);
                  }
                  return res.send(code);
                };
              }
              return oldrender.call(res, view, options, function(err, code) {
                if (err) {
                  return fn(err);
                }
                return Inlines.call(code, fn);
              });
            };
          }
          return realNext();
        };
        url = URL.parse(req.url);
        path = decodeURIComponent(url.pathname);
        file = Path.join('/', path);
        if (_this.can_serve_file(file)) {
          util.log('trying to serve ' + file);
          server = ((_ref = _this.files[file]) != null ? _ref.cache : void 0) ? _this.servers.caching : _this.servers.normal;
          return _this.serve_file(req, res, file, server, next);
        } else {
          return _this.servers.caching(req, res, next);
        }
      };
    };

    Pipeline.prototype.get_file = function(file, cb) {
      var relcwd,
        _this = this;
      relcwd = Path.relative(this.options.assets, process.cwd());
      file = Path.resolve('/' + relcwd, file);
      return this.compile_file(file, function(err) {
        if (err) {
          return cb(err);
        }
        return fs.readFile(_this.req_to_cache(file), function(err) {
          return cb.apply(null, arguments);
        });
      });
    };

    Pipeline.prototype.serve_file = function(req, res, file, server, next) {
      var file_defined, _base, _ref,
        _this = this;
      if (((_ref = this.files[file]) != null ? _ref.compiled : void 0) && this.files[file].cache) {
        return server(req, res, next);
      } else {
        file_defined = this.files[file] != null;
        if ((_base = this.files)[file] == null) {
          _base[file] = {};
        }
        this.files[file].serve = true;
        return this.compile_file(file, function(err) {
          if (err) {
            if (!file_defined) {
              delete _this.files[file];
            }
            if ((err != null ? err.code : void 0) === 'asset-pipeline/filenotfound') {
              return next();
            } else {
              util.log('ERROR: ' + err);
              return next(err);
            }
          }
          util.log("publishing " + file);
          return _this.publish_file(file, function(err) {
            if (err) {
              return next(err);
            }
            return server(req, res, next);
          });
        });
      }
    };

    Pipeline.prototype.check_if_changed = function(file, cb) {
      var _ref,
        _this = this;
      if (!((_ref = this.files[file]) != null ? _ref.compiled : void 0)) {
        return cb();
      } else {
        return this.depmgr.check(file, function(err, changed) {
          if (err) {
            return cb(err);
          }
          if (changed) {
            _this.files[file].compiled = false;
          }
          return cb();
        });
      }
    };

    Pipeline.prototype.compile_file = function(file, mcb) {
      var _this = this;
      return this.check_if_changed(file, function(err) {
        var _ref;
        if (err) {
          return mcb(err);
        }
        if ((_ref = _this.files[file]) != null ? _ref.compiled : void 0) {
          return mcb(null, false);
        }
        return util.NoConcurrent("compile " + _this.id + " " + file, mcb, function(cb) {
          var finish;
          util.log("compiling " + file);
          finish = function(err) {
            var _base;
            if (!err) {
              if ((_base = _this.files)[file] == null) {
                _base[file] = {};
              }
              util.log("compiled successfully: " + file);
              _this.files[file].compiled = true;
              _this.save_cache_state();
            }
            return cb(err, true);
          };
          return MakePath.find(_this.options.assets, file, function(err, found) {
            if (err) {
              _this.depmgr.resolves_to(file, null);
              return cb(err);
            }
            _this.depmgr.resolves_to(file, found.path);
            return _this.send_to_pipeline(file, found.path, found.extlist, function(err) {
              var _ref1;
              if (err) {
                return cb(err);
              }
              if ((_ref1 = _this.files[file]) != null) {
                delete _ref1.published;
              }
              return _this.publish_file(file, finish);
            });
          });
        });
      });
    };

    Pipeline.prototype.publish_file = function(file, cb) {
      var _this = this;
      if ((this.files[file] != null) && this.files[file].serve && !this.files[file].published) {
        return util.link_file(this.req_to_cache(file), this.req_to_static(file), function(err) {
          if (!err) {
            _this.files[file].published = true;
          }
          return cb(err);
        });
      } else {
        return cb();
      }
    };

    Pipeline.prototype.actual_pipeline = function(data, pipes, filename, attrs, cb) {
      var Compiler, newfile, oldfile, pipe, _ref, _ref1,
        _this = this;
      if (pipes.length === 0) {
        return cb(null, data);
      }
      data = data.toString('utf8');
      pipe = pipes.shift();
      if (pipe.ext === '') {
        return this.actual_pipeline(data, pipes, pipe.file, attrs, cb);
      }
      Compiler = (_ref = MakePath.mappings[pipe.ext]) != null ? _ref[pipe.dst] : void 0;
      if (!Compiler) {
        return cb(new Error('compiler not found'));
      }
      oldfile = this.path_to_req(filename);
      newfile = this.path_to_req(pipe.file);
      this.depmgr.clear_deps(newfile);
      this.depmgr.depends_on(newfile, oldfile);
      attrs.filename = pipe.file;
      if (this.options.plugin_config != null) {
        attrs.plugin_config = (_ref1 = this.options.plugin_config[pipe.ext]) != null ? _ref1 : this.options.plugin_config[pipe.ext.replace(/^\./)];
      }
      if (this.options.dependencies != null) {
        attrs.dependencies = this.options.dependencies;
      }
      return Compiler(data, attrs, function(err, result) {
        if (err) {
          return cb(err);
        }
        return _this.actual_pipeline(result, pipes, pipe.file, attrs, cb);
      });
    };

    Pipeline.prototype.send_to_pipeline = function(reqfile, file, plugins, cb) {
      var dest,
        _this = this;
      dest = Path.join(this.tempDir, reqfile);
      this.depmgr.clear_deps(this.path_to_req(file));
      return fs.readFile(file, function(err, data) {
        if (err) {
          return cb(err);
        }
        return _this.actual_pipeline(data, plugins, file, {
          pipeline: _this
        }, function(err, data) {
          if (err) {
            return cb(err);
          }
          return util.write_file(dest, data, cb);
        });
      });
    };

    Pipeline.prototype.register = function(orig_name, static_name, cb) {
      var _this = this;
      return util.link_file(this.req_to_cache(orig_name), this.req_to_static(static_name), function(err, res) {
        if (err) {
          return cb(err);
        }
        _this.files[static_name] = {
          cache: true,
          serve: true,
          compiled: true,
          published: true
        };
        return cb(null, Path.join(_this.options.mount_point, static_name));
      });
    };

    Pipeline.prototype.path_to_req = function(path) {
      return Path.join('/', Path.relative(this.options.assets, path));
    };

    Pipeline.prototype.path_to_cache = function(path) {
      return Path.join(this.tempDir, this.path_to_req(path));
    };

    Pipeline.prototype.req_to_cache = function(path) {
      return Path.join(this.tempDir, path);
    };

    Pipeline.prototype.req_to_static = function(path) {
      return Path.join(this.staticDir, path);
    };

    return Pipeline;

  })();

  module.exports = Pipeline;

}).call(this);
